<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><title>Chapter 3: The Untestables - Test-Driven Development MOOC</title><meta content="width=device-width, initial-scale=1.0" name="viewport"><link href="https://cdn.jsdelivr.net/npm/@openfonts/open-sans-condensed_all@1.44.2/index.min.css" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/@fontsource/roboto-slab@5.0.17/index.min.css" rel="stylesheet"><link href="https://cdn.simplecss.org/simple.css" rel="stylesheet"><link href="/styles.css" rel="stylesheet"><script defer src="/custom-elements.mjs" type="module"></script></head><body><nav aria-label="Table of contents" id="site-navigation"><div class="nav-title">TDD MOOC</div><ul><li><a href="/">Course overview</a></li><li><a href="/practicalities/">Practicalities (Spring 2025)</a><ul><li><a href="/enrollment/">Enrollment for study credits</a></li></ul></li><li><span>Course material</span><ul><li><a href="/exercises/">Exercises</a></li><li><a href="/1-tdd/">Chapter 1: What is TDD</a></li><li><a href="/2-design/">Chapter 2: Refactoring and design</a></li><li><a aria-current="page" href="/3-challenges/">Chapter 3: The Untestables</a></li><li><a href="/4-legacy-code/">Chapter 4: Legacy code</a></li><li><a href="/5-advanced/">Chapter 5: Advanced techniques</a></li><li><a href="/6-afterword/">Chapter 6: To infinity and beyond</a></li></ul></li></ul><ul><li><a href="/credits/">About the material</a></li><li><a href="/coaching/">Technical coach for your team</a></li></ul></nav><main><h1>Chapter 3: The Untestables</h1><p>There are things which make testing more challenging. Many of them are global variables of sorts. Global variables cause spooky action at a distance. Do the same thing over and over again, and get a different result. Tests may randomly pass or fail, depending on the order in which they are run.</p>
<h2><a href="#how-to-make-any-code-testable" id="how-to-make-any-code-testable">How to make any code testable</a></h2>
<p>In general there are two options, the first one being simpler:</p>
<ul>
<li><strong>Pass in the result of the untestable thing as a parameter.</strong></li>
</ul>
<div style="columns: 2">
<div>
<p>Before</p>
<pre><code>fn():
  ...
  ‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è
  ...
</code></pre>
</div>
<div style="break-before: column">
<p>After</p>
<pre><code>fn(something):
  ...
  ...
</code></pre>
</div>
</div>
<ul>
<li><strong>Extract the untestable thing to a method and override it in a subclass.</strong> Or in a language with first-class functions, extract it to a function and pass in the untestable function as a parameter.</li>
</ul>
<div style="columns: 2">
<div>
<p>Before</p>
<pre><code>fn():
  ...
  ‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è
  ...
</code></pre>
</div>
<div style="break-before: column">
<p>After</p>
<pre><code>fn():
  ...
  something()
  ...
  
something():
  ‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è
</code></pre>
</div>
</div>
<p>Tests can then replace the untestable thing with a value object or a test double.</p>
<h2><a href="#test-doubles" id="test-doubles">Test doubles</a></h2>
<p>If the SUT (system under test) is not a pure function and it's hard to test together with the real objects, its dependencies can be replaced with <a href="https://martinfowler.com/bliki/TestDouble.html">test doubles</a>. The dependencies can be provided as method or constructor arguments (aka dependency injection).</p>
<p>There are five main categories of test doubles:</p>
<ul>
<li><strong>Dummy</strong> is a placeholder to make the code compile, but doesn't affect the SUT.</li>
<li><strong>Stub</strong> returns data to the SUT e.g. using hard-coded method return values.</li>
<li><strong>Spy</strong> records how the SUT calls the spy, so that the test can afterwards assert on the recorded data.</li>
<li><strong>Mock</strong> contains pre-recorded expectations on how the SUT should call it, and will itself automatically verify the expectations. Requires a mocking framework.</li>
<li><strong>Fake</strong> is a simplified implementation of a dependency, not appropriate for production use, e.g. persistence layer based on a hashmap.</li>
</ul>
<p>Only mock types you own.</p>
<aside class="recommended-reading"><h5 class="heading">üìñ Recommended reading</h5><div class="content">
<ul>
<li><a href="https://archive.ph/2yx7C">Test Doubles: Dummy, Stub, Spy, Mock &amp; Fake</a></li>
<li><a href="https://medium.com/@xpmatteo/how-i-learned-to-love-mocks-1-fb341b71328">How I learned to love mocks</a></li>
</ul>
</div></aside>
<h3><a href="#london-school-of-tdd" id="london-school-of-tdd">London school of TDD</a></h3>
<p>Mock objects were invented in a London meetup, and it gave birth to a mock-based outside-in approach to TDD, which is commonly called London style TDD. This is in contrast to Detroit/Chicago style TDD, where the code is typically written bottom-up and dependencies are faked only when they complicate testing (named such because Chrysler's C3 project, which gave birth to Extreme Programming, happened in Detroit). They are also known as mockist and classicist styles.</p>
<p>London style TDD focuses on the communication protocols between objects sending messages to each other. It goes hand-in-hand <a href="https://groups.google.com/g/growing-object-oriented-software/c/-t6fp3392oM/m/QO342CHAAwAJ">[1]</a> with the <a href="https://www.purl.org/stefan_ram/pub/doc_kay_oop_en">original vision of object-oriented programming</a>, by <a href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a>, where objects are like individual computers on the network sending messages to each other (in which sense Erlang is the most object-oriented programming language).</p>
<p>When using mock objects, it's important to understand the object-oriented style for which they were created. Otherwise, over-mocking may lead to tight coupling between tests and implementation details. The best description of how mock objects were meant to be used is the book <em>Growing Object-Oriented Software, Guided by Tests</em> (Steve Freeman, Nat Pryce 2009).</p>
<aside class="recommended-reading"><h5 class="heading">üìñ Recommended reading</h5><div class="content">
<ul>
<li><a href="https://web.archive.org/web/20230318070013/http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html">A Brief History of Mock Objects</a></li>
<li><a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627">Growing Object-Oriented Software, Guided by Tests</a> - how the inventors of mock objects use them</li>
</ul>
</div></aside>
<h2><a href="#singletons" id="singletons">Singletons</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton</a> is an anti-pattern. It is the object-oriented equivalent of a global variable. Instead, <a href="http://www.butunclebob.com/ArticleS.UncleBob.SingletonVsJustCreateOne">just create one</a>.</p>
<aside class="recommended-reading"><h5 class="heading">üìñ Recommended reading</h5><div class="content">
<ul>
<li><a href="http://www.butunclebob.com/ArticleS.UncleBob.SingletonVsJustCreateOne">Singleton vs. Just Create One</a></li>
</ul>
</div></aside>
<h2><a href="#file-system" id="file-system">File system</a></h2>
<p>The file system is a global variable which persists between test executions.</p>
<p>Firstly, decouple as much code from the file system as possible. If you have code which reads data from a file and then does something with the data, separate it into two functions that can be run in isolation: one which does the file reading, and another which does the data processing.</p>
<p>Sometimes people have test data in files. It's better to have all data related to a test in the same file as the test (and preferably inline inside the test method). Otherwise, you'll need to jump between two files, which makes understanding the test harder.</p>
<p>After you have decoupled file handling and business logic, the file handling will still need to be tested. Files are unavoidable then (don't try mocking the file system).</p>
<p>If a test needs to read from the disk, you can create small example files and commit them into version control. The tests can then read those test resources.</p>
<p>If a test needs to write to the disk, create a unique temporary directory on test setup and delete it recursively on teardown.</p>
<p>Note: If the test process is killed or there are file locks, the teardown may not be able to delete the temporary directory. Avoid using <code>/tmp</code> and instead place the temporary directory inside the project directory, under the build target directory, so that any stale directories will be removed on a clean build.</p>
<h2><a href="#database" id="database">Database</a></h2>
<p>The database is a global variable which persists between test executions.</p>
<p>Make it easy to run the tests locally. <a href="https://docs.docker.com/compose/">Docker Compose</a> makes it easy to start up a database without needing to install it. For cloud-only databases, using a development instance in the cloud is necessary. If more than one person (or process) uses the same database, then care must be taken to isolate the tests from parallel test runs.</p>
<p>Usually tests create the database schema on test setup, and remove it on teardown. Another style is to remove and recreate the schema on test setup, which makes it the responsibility of the next test to clean up what the previous test produced. Clean-before allows peeking the data after a test run, but you would still need to focus run a single test, so commenting out the teardown or using a sleep gives the same effect with the clean-after approach. (Mom always told to clean up after yourself.)</p>
<p>In focused integration tests, it may be possible to run each test in a rollback-only transaction. This should make tests faster by avoiding the need to recreate the database schema for each test. If more than one thread is involved or the SUT is complex, this strategy is usually not possible.</p>
<p>Tests may create their own test data, or there may be a shared set of test data in the database. The former makes tests more understandable and decoupled from each other. The latter can be used for also testing database migrations.</p>
<p>The test schema name may be hard-coded or unique. Unique names for each test make it possible to run tests in parallel. If the test process is killed, test teardown is never executed, so the tests should automatically remove stale test schemas (especially if using a shared long-running database instead of a local container/VM), or you will eventually learn the database's soft and hard limits.</p>
<p><em>Never run tests against a production database.</em> One safeguard is for the tests to only connect to a database whose name starts with "test".</p>
<p>Database tests can be made faster by <a href="https://pythonspeed.com/articles/faster-db-tests/">disabling fsync or using a RAM disk</a>.</p>
<h3><a href="#dead-ends" id="dead-ends">Dead ends</a></h3>
<p>You <em>could</em> replace the database with an in-memory fake implementation for tests (e.g. hashmap). It will make the tests faster, but will require maintaining two parallel implementations - the real and the fake persistence layer. It works in simple cases, but gets harder the more database code there is. Even when using <a href="https://blog.thecodewhisperer.com/permalink/getting-started-with-contract-tests">contract tests</a> to make the implementations functionally equivalent, they will be leaky abstractions with non-obvious differences (transactions, foreign key constraints etc.). It's better to decouple business logic from persistence: you won't need to fake dependencies if you have no dependencies.<a href="https://imgflip.com/i/5kxd8x">¬π</a></p>
<p>Some people use an embedded in-memory database in tests and a different database in production, for example HSQLDB vs PostgreSQL. This is a road to madness. Even if SQL is a standard,<a href="https://xkcd.com/927/">¬≤</a> each implementation is different, so you will anyways need to run the tests against both databases. It might avoid having to install a database and the data will be removed after the test process exits, but nowadays <code>docker compose up -d db</code> is easy and even with an in-memory database you will need to handle isolation between test cases. Speed is not an argument either; a PostgreSQL which is already running is faster than a HSQLDB that needs to start every test run, not to speak of runtime performance. Most importantly, you would be limited to a subset of SQL that works on both databases, or you will need to maintain alternative versions of the queries; you would miss out on useful database-specific features such as <a href="https://www.postgresql.org/docs/13/plpgsql-trigger.html">triggers/stored procedures</a> and <a href="https://medium.com/pyankit/postgres-range-types-are-dope-ca18923f3d46">range types</a>. Summa summarum, use the same technology in tests as in production.</p>
<p>You just saved 5+ years of experimenting.</p>
<h2><a href="#network-sockets" id="network-sockets">Network sockets</a></h2>
<p>Network socket port numbers are a global variable at the operating system level.</p>
<p>If using a shared <a href="https://martinfowler.com/articles/continuousIntegration.html">continuous integration</a> server, there can be many builds running on the same machine and they compete for the same port numbers. Even when running tests locally, you will typically have an application instance for manual testing running at the same time as the automated tests. The local development instance may use hard-coded ports, but the tests should allocate a random free port for the database and web server.</p>
<p>Most servers you can bind to listen on port 0 and the operating system will assign it an unused port number. After the server has started, you can find out what port was assigned to it and use that in the tests. <a href="https://docs.docker.com/compose/reference/port/"><code>docker compose port</code></a> is handy for that. The other approach is to programmatically bind a socket to port 0, check what port number was assigned, close the socket, and then use that port number for starting the actual server - a port collision should be unlikely.</p>
<p>P.S. Docker by default binds to network interface 0.0.0.0 and it <a href="https://github.com/moby/moby/issues/22054">bypasses the firewall</a>, so your development servers will be <em>publicly accessible even if your firewall is configured to block all incoming connections</em>. Always bind explicitly to 127.0.0.1 when publishing container ports to the host.</p>
<h2><a href="#time" id="time">Time</a></h2>
<p>Time is a global variable which is ever changing (hopefully monotonically increasing).</p>
<p>Code which reads the current time (e.g. using <code>new Date()</code>) is inherently untestable. Instead, pass in the current time as a method parameter, or inject a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Clock.html">clock</a> which can be replaced with a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Clock.html#fixed(java.time.Instant,java.time.ZoneId)">fake clock</a> in tests.</p>
<h2><a href="#concurrency" id="concurrency">Concurrency</a></h2>
<p>The order of memory reads and writes between parallel threads, and the operating system's context switching, are unpredictable global variables.</p>
<p><em>If a test fails randomly, don't ignore it as an outlier.</em> The code <em>has</em> a concurrency bug, in the production or test code. Save any stack traces and logs of the failure, and <em>inspect the code ruthlessly</em>, until you know why it failed. It's important to know the <a href="https://en.wikipedia.org/wiki/Memory_model_(programming)">memory model</a> of the programming language and the CPU.</p>
<p>Minimize the amount of code that needs to be thread-safe. Use <a href="https://en.wikipedia.org/wiki/Concurrency_pattern">concurrency abstractions</a> which allow most of the code to be single-threaded. <a href="https://en.wikipedia.org/wiki/Immutable_object">Immutability</a> makes the code easier to reason about, also in single-threaded code.</p>
<p>Don't use <code>sleep()</code> in tests. The sleep time is either too long, making the tests slower, or too short, making them <a href="https://semaphoreci.com/community/tutorials/how-to-deal-with-and-eliminate-flaky-tests">flaky</a> (i.e. they fail randomly). Instead, react to events or use polling.</p>
<p>Concurrency artifacts such as <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CountDownLatch.html">CountDownLatch</a> and <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CyclicBarrier.html">CyclicBarrier</a> are useful for unit testing concurrent code. With them you can make thread 1 wait at point A, until thread 2 has arrived at point B.</p>
<p><a href="https://www.goodreads.com/quotes/506689-program-testing-can-be-used-to-show-the-presence-of">Testing cannot prove</a> that code is thread-safe, but together with code review, you can get quite far by writing a test which executes lots of tasks in parallel and then asserts invariants about what the tasks did. For example, each write happened exactly once, each task saw a consistent view of the state, tasks could read their own writes, and so on.</p>
<p>Always have a timeout for asynchronous tests, in case the code gets stuck in an infinite loop or deadlock or doesn't send some event. The timeout needs to be long enough to not be triggered randomly when the computer is overloaded, but short enough that you don't need to wait long for the tests to fail, especially if the wait time is <code>NumberOfTests * Timeout</code>.</p>
<aside class="recommended-reading"><h5 class="heading">üìñ Recommended reading</h5><div class="content">
<ul>
<li><a href="https://semaphoreci.com/community/tutorials/how-to-deal-with-and-eliminate-flaky-tests">How to Find and Eliminate Flaky Tests</a></li>
</ul>
</div></aside>
<h2><a href="#randomness" id="randomness">Randomness</a></h2>
<p>It's desirable for tests to pass or fail reliably. But what if the code being tested is meant to have randomness? If you can't anymore assert exact values, you will need to approach it like <a href="https://increment.com/testing/in-praise-of-property-based-testing/">property-based testing</a> and assert <em>invariants</em>.</p>
<p>For example, let's test a function which returns random integers between 1 and 10. You can call it lots of times and check that all values are within the range 1 to 10. You may also check that, with a sufficiently large sample size, each of the integers between 1 and 10 is returned at least once. You may also check that the values are returned in unpredictable order: build a few lists of same length from the return values, and check that the list contents are different. Depending on the domain, there might be other restrictions as well. For example, when dealing cards from a deck of cards, each card appears exactly once.</p>
<p>But even if you assert that the random values are not predictable, once in a blue moon the values could be returned in seemingly predictable order<a href="https://web.archive.org/web/20230304094645/https://dilbert.com/strip/2001-10-25">¬π</a> and your tests would fail. To improve repeatability, you could always use the same seed for the pseudorandom number generator. Or better yet, choose randomly from a couple different hard-coded seeds, so that the tests cannot be coupled to any single predictable random order.</p>
<p>(Testing whether something is true randomness is outside the scope of this course. That's in the realm of mathematics and not TDD.)</p>
<h2><a href="#user-interface" id="user-interface">User interface</a></h2>
<p>Tests should be sensitive to behavior changes and insensitive to structure changes. This is even more important in the user interface. Changing the visual style or layout of the UI, should not break behavioral tests.</p>
<p>There are patterns like <a href="https://martinfowler.com/eaaDev/PassiveScreen.html">passive view</a> which try to separate the logic and visuals of the UI, to make the logic more testable. With the advent of <a href="https://reactjs.org/">React</a>, UI components can be written as stateless functions, which makes testing them easier.</p>
<h3><a href="#unit-testing-web-app-components" id="unit-testing-web-app-components">Unit testing web app components</a></h3>
<p>Asserting on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText">innerText</a> of a component (after whitespace normalization) produces tests which are decoupled from visual changes.</p>
<p>Asserting the presence/absence of a CSS class is useful for testing logic that is observable only visually. Make sure to use the same constant for presence and absence checks; a mispelled <!-- sic --> CSS class is always absent.</p>
<h3><a href="#end-to-end-testing-web-apps" id="end-to-end-testing-web-apps">End-to-end testing web apps</a></h3>
<p>Don't click buttons directly in test code. Create an automation layer of high-level operations and call those. The tests should focus on <em>what</em> the system does, and the automation layer on <em>how</em> the system does it. That way when the UI changed, only the automation layer needs to be updated, instead of fixing all tests individually.</p>
<p>Prefer selecting elements based on the visible text on the button/link/label; it makes the tests easier to read. But don't be afraid to add extra IDs, classes and <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes">data attributes</a> to simplify testing.</p>
<p>Have only a few end-to-end tests. They are slow and flaky. Prefer unit tests. Set a hard limit for how many end-to-end tests the whole application may have (‚â§10 for even big apps) and stick to it. End-to-end tests should only check that things are wired together, not behavioral correctness. Overreliance on end-to-end tests can <a href="https://building.nubank.com.br/why-we-killed-our-end-to-end-test-suite/">grind development to a halt</a>.</p>
<aside class="recommended-reading"><h5 class="heading">üìñ Recommended reading</h5><div class="content">
<ul>
<li><a href="https://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam">Integrated Tests Are A Scam</a></li>
</ul>
</div></aside>
<h3><a href="#visual-testing" id="visual-testing">Visual testing</a></h3>
<p>It's hard to write an assertion that something looks good. But for a human it's easy to check it visually, and the computer can compare whether the pixels have changed since the last approval.</p>
<p>There are tools like <a href="https://storybook.js.org/">Storybook</a> for rendering UI components in various states, and it's possible to <a href="https://storybook.js.org/docs/react/workflows/visual-testing">take a screenshot</a> of the result and check whether it has changed.</p>
<p>Optimize the diff for humans. Even video and audio can be diffed as an image.</p>
<aside class="recommended-reading"><h5 class="heading">üìñ Recommended reading</h5><div class="content">
<ul>
<li><a href="https://www.youtube.com/watch?v=5_IW7npQk9k">You're Testing WHAT?</a></li>
</ul>
</div></aside>
<hr />
<p>Proceed to <a href="/4-legacy-code">Chapter 4: Legacy code</a> or <a href="/exercises">Exercises</a></p>
</main><footer><div>This course was brought to you by <a href="https://twitter.com/EskoLuontola">Esko Luontola</a> and <a href="https://nitor.com/">Nitor</a>.</div><div><a href="https://github.com/luontola/tdd-mooc"><small>Website source code</small></a></div><div><a href="/credits"><small>Credits and about the material</small></a></div><div class="social-links-footer"><a aria-label="Mooc.fi Twitter profile" href="https://twitter.com/moocfi" title="Mooc.fi Twitter profile"><svg aria-hidden="true" role="img" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z" fill="currentColor"></path></svg></a><a aria-label="Mooc.fi Facebook profile" href="https://www.facebook.com/Moocfi" title="Mooc.fi Facebook profile"><svg aria-hidden="true" role="img" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z" fill="currentColor"></path></svg></a><a aria-label="Mooc.fi YouTube channel" href="https://www.youtube.com/@mooc-fi" title="Mooc.fi YouTube channel"><svg aria-hidden="true" role="img" viewBox="0 0 576 512" xmlns="http://www.w3.org/2000/svg"><path d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z" fill="currentColor"></path></svg></a></div><div class="university-links-footer"><div class="hy-logo"><a href="https://www.helsinki.fi"><svg aria-hidden="true" focusable="false" viewBox="0 0 1000 1000"><path d="M452 0h96v97h-96V0zm0 903h96v97h-96v-97zm380-358q-32-20-38-74-25 3-44-3-28-10-40-42-6-13-12-47t-13-52q-12-32-33-56-33-35-74-50-37-14-78-11 30 19 37 46 6 23-7 41t-36 19-42-12q-8-5-35-27-22-18-40-26-26-12-58-12-25 0-51 13 24 3 40 16 13 12 24 32 3 7 16 39 10 23 27 36t44 22q-13 6-38 6-29 0-55-15-20-11-45-36t-43-36q-28-16-61-16-16 0-29 4t-19 9q23 3 42 14 23 15 23 34 0 11-7 17t-19 5-23-12q-18-20-43-33t-54-12q-13 0-26 3T0 339q34 5 58 28t45 72q15 35 33 51 24 23 64 23 5 0 29-3 20-2 31 0 17 2 27 13 9 8 12 21 2 6 5 23 2 15 6 23 10 21 28 31 21 11 56 11-19 19-54 21-32 2-65-9t-49-28q2 46 25 80 25 37 68 50 49 14 113-4 18-5 30-1t19 24q16 41 71 35 48-5 79 6t59 42q8-81-77-135-15-9-23-19-6-8-9-19l-4-17q16 18 38 28 17 8 43 14 82 10 110 52 2-23-6-42-6-15-19-29-10-10-26-22-19-15-23-18-11-10-13-18 19 12 36 17t38 5q7-1 27-6t31-4q16 0 28 7 15 9 27 29 29-18 68-15 35 3 64 21-12-30-34-52-17-18-44-33-12-7-47-23-28-14-43-24zm-284 36h-96v-97h96v97z" fill="currentColor"></path></svg><span>University of Helsinki</span></a></div><div class="moocfi-logo"><a href="https://www.mooc.fi"><img alt="" src="/moocfi-logo.png"><span>MOOC.fi</span></a></div></div></footer></body></html>